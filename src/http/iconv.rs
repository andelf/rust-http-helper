/*!

Binding for the iconv library

 */

use std::cast;
use std::vec;
use std::io;
use std::io::{IoResult, IoError};
use std::os::errno;
use std::libc::{E2BIG, EILSEQ, EINVAL};
use std::ptr;
use std::str;
use std::vec::MutableCloneableVector;

/* automatically generated by rust-bindgen */

use std::libc::{c_schar, size_t, c_int, c_void};
#[allow(non_camel_case_types)]
type iconv_t = *mut c_void;

#[cfg(target_os = "macos")]
#[link(name = "iconv")]
extern "C" {
    fn iconv_open(__tocode: *c_schar, __fromcode: *c_schar) -> iconv_t;
    fn iconv(__cd: iconv_t, __inbuf: *mut *mut c_schar,
                 __inbytesleft: *mut size_t, __outbuf: *mut *mut c_schar,
                 __outbytesleft: *mut size_t) -> size_t;
    fn iconv_close(__cd: iconv_t) -> c_int;
}

// iconv is part of linux glibc
#[cfg(target_os = "linux")]
extern "C" {
    fn iconv_open(__tocode: *c_schar, __fromcode: *c_schar) -> iconv_t;
    fn iconv(__cd: iconv_t, __inbuf: *mut *mut c_schar,
                 __inbytesleft: *mut size_t, __outbuf: *mut *mut c_schar,
                 __outbytesleft: *mut size_t) -> size_t;
    fn iconv_close(__cd: iconv_t) -> c_int;
}
/* automatically generated ends */

/// The representation of a iconv converter
pub struct Converter {
    priv cd: iconv_t,
}

impl Converter {
    /// Creates a new Converter from ``from`` encoding and ``to`` encoding.
    pub fn new(from: &str, to: &str) -> Converter {
        let handle = from.with_c_str(|from_encoding| {
                to.with_c_str(|to_encoding| unsafe {
                        iconv_open(to_encoding, from_encoding)
                    })
            });
        if handle == -1 as iconv_t {
            fail!("Error creating conversion descriptor from {:?} to {:?}", from, to);
        }
        Converter { cd: handle }
    }

    /// Convert from input into output.
    /// Returns (bytes_read, bytes_written, errno).
    pub fn convert(&self, input: &[u8], output: &mut [u8]) -> (uint, uint, c_int) {
        let input_left = input.len() as size_t;
        let output_left = output.len() as size_t;

        if input_left > 0 && output_left > 0 {
            let input_ptr = input.as_ptr();
            let output_ptr = output.as_ptr();

            let ret = unsafe { iconv(self.cd,
                                     cast::transmute(&input_ptr), cast::transmute(&input_left),
                                     cast::transmute(&output_ptr), cast::transmute(&output_left))
            };
            let bytes_read = input.len() - input_left as uint;
            let bytes_written = output.len() - output_left as uint;

            return (bytes_read, bytes_written, if ret == -1 as size_t { errno() as c_int } else { 0 })
        } else if input_left == 0 && output_left > 0 {
            let output_ptr = output.as_ptr();

            let ret = unsafe { iconv(self.cd,
                                     ptr::mut_null::<*mut c_schar>(), cast::transmute(&input_left),
                                     cast::transmute(&output_ptr), cast::transmute(&output_left))
            };

            let bytes_written = output.len() - output_left as uint;

            return (0, bytes_written, if -1 as size_t == ret { errno() as c_int } else { 0 })
        } else {
            let ret = unsafe { iconv(self.cd,
                                     ptr::mut_null::<*mut c_schar>(), cast::transmute(&input_left),
                                     ptr::mut_null::<*mut c_schar>(), cast::transmute(&output_left))
            };

            return (0, 0, if -1 as size_t == ret { errno() as c_int } else { 0 })
        }
    }
}


impl Drop for Converter {
    fn drop(&mut self) {
        unsafe { iconv_close(self.cd) };
    }
}

/// A ``Reader`` which does iconv convert from another Reader.
pub struct IconvReader<R> {
    priv inner: R,
    priv conv: Converter,
    priv buf: ~[u8],
    priv read_pos: uint,
    priv write_pos: uint,
    priv err: Option<IoError>,
    priv tempbuf: ~[u8],        // used when outbut is too small and can't make a single convertion
}

impl<R:Reader> IconvReader<R> {
    pub fn new(r: R, from: &str, to: &str) -> IconvReader<R> {
        let conv = Converter::new(from, to);
        IconvReader { inner: r, conv: conv,
                      buf: vec::from_elem(8*1024, 0u8),
                      read_pos: 0, write_pos: 0, err: None,
                      tempbuf: ~[], // small buf allocate dynamicly
        }
    }

    fn fill_buf(&mut self) {
        if self.read_pos > 0 {
            let nremain_unread = self.write_pos - self.read_pos;
            unsafe {
                ptr::copy_memory::<u8>(self.buf.as_mut_ptr(),
                                       cast::transmute(self.buf.unsafe_mut_ref(self.read_pos)),
                                       self.write_pos - self.read_pos);
            }

            self.write_pos -= self.read_pos;
            self.read_pos = 0;
        }
        match self.inner.read(self.buf.mut_slice_from(self.write_pos)) {
            Ok(nread) => {
                self.write_pos += nread;
            }
            Err(e) => {
                self.err = Some(e);
            }
        }
    }
}

impl<R:Reader> Reader for IconvReader<R> {
    fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {
        if self.tempbuf.len() != 0 {
            let nwrite = buf.copy_from(self.tempbuf);
            if nwrite < self.tempbuf.len() {
                self.tempbuf = self.tempbuf.slice_from(nwrite).into_owned();
            } else {
                self.tempbuf = ~[];
            }
            return Ok(nwrite);
        }

        while self.write_pos == 0 || self.read_pos == self.write_pos {
            if self.err.is_some() {
                return Err(self.err.clone().unwrap());
            }

            self.fill_buf();
        }

        let (nread, nwrite, err) = self.conv.convert(self.buf.slice(self.read_pos, self.write_pos), buf);

        self.read_pos += nread;

        match err {
            EILSEQ => {
                debug!("An invalid multibyte sequence has been encountered in the input.");
                return Err(io::standard_error(io::InvalidInput));
            }
            EINVAL => {
                debug!("An incomplete multibyte sequence has been encountered in the input.");
                // FIXME fill_buf() here is ugly
                self.fill_buf();
                return Ok(nwrite);
            }
            E2BIG => {
                debug!("There is not sufficient room at *outbuf.");
                // FIXED: if outbuf buffer has size 1? Can't hold a
                if nread == 0 && nwrite == 0 && buf.len() > 0 {
                    // outbuf too small and can't conv 1 rune
                    let mut tempbuf = vec::from_elem(8, 0u8);
                    assert_eq!(self.tempbuf, ~[]);
                    let (nread, temp_nwrite, err) = self.conv.convert(self.buf.slice(self.read_pos, self.write_pos), tempbuf);
                    self.read_pos += nread;
                    // here we mostly will write 1 or 2 bytes here.
                    // try avoiding return Ok(0)
                    let nwrite = buf.copy_from(tempbuf);
                    self.tempbuf = tempbuf.slice(nwrite, temp_nwrite).into_owned();
                    match err {
                        EILSEQ => return Err(io::standard_error(io::InvalidInput)),
                        _ => return Ok(nwrite);
                    }
                }
                return Ok(nwrite);
            }
            0 => {
                return Ok(nwrite);
            }
            _ => unreachable!()
        }
    }
}

// TODO: use Result<> instead of Option<> to indicate Error
fn convert_bytes(inbuf: &[u8], from: &str, to: &str) -> Option<~[u8]> {
    let converter = Converter::new(from, to);
    let mut outbuf_size = inbuf.len() * 2;
    let mut total_nread = 0;
    let mut total_nwrite = 0;

    let mut outbuf = vec::with_capacity(outbuf_size);
    unsafe { outbuf.set_len(outbuf_size) };

    while total_nread < inbuf.len() {
        let (nread, nwrite, err) = converter.convert(inbuf.slice_from(total_nread),
                                                     outbuf.mut_slice_from(total_nwrite));

        total_nread += nread;
        total_nwrite += nwrite;

        match err {
            EINVAL | EILSEQ => return None,
            E2BIG => {
                outbuf_size += inbuf.len();
                outbuf.reserve(outbuf_size);
                unsafe { outbuf.set_len(outbuf_size) };
            }
            _ => ()
        }
    }

    unsafe { outbuf.set_len(total_nwrite) };
    outbuf.shrink_to_fit();

    return Some(outbuf);
}


/// Can be encoded to bytes via iconv
pub trait IconvEncodable {
    /// Encode to bytes with encoding
    fn encode_with_encoding(&self, encoding: &str) -> Option<~[u8]>;
}

impl<'a> IconvEncodable for &'a [u8] {
    fn encode_with_encoding(&self, encoding: &str) -> Option<~[u8]> {
        convert_bytes(*self, "UTF-8", encoding)
    }
}

impl<'a> IconvEncodable for &'a str {
    fn encode_with_encoding(&self, encoding: &str) -> Option<~[u8]> {
        return self.as_bytes().encode_with_encoding(encoding);
    }
}

/// Can be decoded to str via iconv
pub trait IconvDecodable {
    /// Decode to str with encoding
    fn decode_with_encoding(&self, encoding: &str) -> Option<~str>;
}

impl<'a> IconvDecodable for &'a [u8] {
    fn decode_with_encoding(&self, encoding: &str) -> Option<~str> {
        convert_bytes(*self, encoding, "UTF-8").and_then(|bs| {
                str::from_utf8(bs).map(|s| {
                        s.into_owned()
                    })
            })
    }
}


#[cfg(test)]
mod test {
    use std::vec;
    use std::io;
    use std::io::BufReader;

    use super::{IconvReader, IconvEncodable, IconvDecodable};


    #[test]
    fn test_reader() {
        let a = "噗哈";
        let cont = a.repeat(1024);

        let r = BufReader::new(cont.as_bytes());
        let mut cr = IconvReader::new(r, "utf-8", "gbk");

        let mut nread = 0;
        loop {
            match cr.read_bytes(4) {
                Ok(ref seg) if seg.len() == 4 => {
                    assert_eq!(seg, &~[224, 219, 185, 254]);
                    nread += 4;
                }
                Err(ref e) if e.kind == io::EndOfFile => {
                    break;
                }
                _ => {
                    unreachable!();
                }
            }
        }
        assert_eq!(nread, 1024 * 4);
    }


    #[test]
    fn test_encoder_normal() {
        assert_eq!("".encode_with_encoding("latin1").unwrap(), ~[]);

        let a = "哈哈";
        assert_eq!(a.encode_with_encoding("gbk").unwrap(), ~[0xb9, 0xfe, 0xb9, 0xfe]);

        let b = a.repeat(1024);
        for ch in b.encode_with_encoding("gbk").unwrap().chunks(4) {
            assert_eq!(ch, &[0xb9, 0xfe, 0xb9, 0xfe]);
        }

        let c = ~[0xe5, 0x93, 0x88, 0xe5, 0x93, 0x88]; // utf8 bytes
        assert_eq!(c.encode_with_encoding("gbk").unwrap(), ~[0xb9, 0xfe, 0xb9, 0xfe]);
    }

    #[test]
    #[should_fail]
    fn test_encoder_fail_creating_converter() {
        assert_eq!("".encode_with_encoding("not_exists").unwrap(), ~[]);
    }

    #[test]
    #[should_fail]
    fn test_encoder_ilseq() {
        let a = ~[0xff, 0xff, 0xff];
        a.encode_with_encoding("gbk").unwrap();
    }

    #[test]
    #[should_fail]
    fn test_encoder_invalid() {
        let a = ~[0xe5, 0x93, 0x88, 0xe5, 0x88]; // incomplete utf8 bytes
        a.encode_with_encoding("gbk").unwrap();
    }

    #[test]
    fn test_decoder_normal() {
        assert_eq!(bytes!("").decode_with_encoding("CP936").unwrap(), ~"");

        let a = ~[0xb9, 0xfe, 0xb9, 0xfe];
        assert_eq!(a.decode_with_encoding("gbk").unwrap(), ~"哈哈");

        let b = vec::from_fn(1000, |i| a[i%4]); // grow to 1000 bytes and fill with a

        for c in b.decode_with_encoding("gbk").unwrap().chars() {
            assert_eq!(c, '哈');
        }
    }

    #[test]
    #[should_fail]
    fn test_decoder_fail_creating_converter() {
        assert_eq!(bytes!("").decode_with_encoding("NOT_EXSITS").unwrap(), ~"");
    }

    #[test]
    #[should_fail]
    fn test_decoder_ilseq() {
        let a = ~[0xff, 0xff, 0xff];
        a.decode_with_encoding("gbk").unwrap();
    }

    #[test]
    #[should_fail]
    fn test_decoder_invalid() {
        let a = ~[0xb9, 0xfe, 0xb9]; // incomplete gbk bytes
        a.decode_with_encoding("gbk").unwrap();
    }
}
